<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>This for kobe</title>
      <link href="2020/11/18/firtblog/"/>
      <url>2020/11/18/firtblog/</url>
      
        <content type="html"><![CDATA[<p>Once upon a time there was a young basketball player who had dreams of becoming one of the greatest basketball players of all-time.<br>He had the opportunity to go to the NBA and play against the greatest players in the world. If that doesn’t get you going, I don’t think anything will.<br>It’s like a dream come true.<br>I couldn’t even dream of this when I was a kid. You know. Just no way possible. It’s just, you know, just a blessing from above.<br>The joy of the game comes from just being out there and just playing. The competitive side of me thinks we can win every game that we play.<br>What I’ve learned is to … always keep going.<br>Do you love the process? That gets you to that. Those boring, agonizing moments. If you love that, then you know you found something that’s really true to you.<br>You know, if you do the work, you work hard enough, dreams come true. Those times when you get up early and you work hard. Those times when you stay up late and you work hard. Those times when you don’t feel like working, you’re too tired, you don’t want to push yourself, but you do it anyway. That is actually the dream.<br>If you’re a fan of mine, you’re a fan of winning. You’re fan of the Lakers. That’s never going to change.<br>Man, I gave my soul to this game. There was nothing more I could give.<br>I wanted to be one of the best basketball players to ever play and anything else that was outside of that lane, I didn’t have time for.<br>It’s not about my jerseys that are hanging up there for me. It’s about the jerseys that were hanging up there before.<br>Growing up and watching all these great players play and learning so much from them. To now be a part of that wall, you know, means everything to me.<br>When you get older you start to understand that really it’s about the next generation. That these championships do come and go. But the most important thing you can do is to pay everything that you’ve learned forward to the next generation to come. And that’s truly how you create something that lasts forever.<br>I love storytelling. Can you imagine, like, winning an Oscar, how ridiculous that would be?Unfortunately for us athletes, we’ve been pigeonholed into thinking that we can only be one thing.<br>I’m here to show people that we can do much more than that. Winning an Oscar, winning an Emmy and an Annie, those are things that are showing other athletes that come after, no, no, there’s more to this thing.<br>The discipline, the commitment, the team, the community. How do I take those lessons and move those here? Having that sharp focus is something that I got from the game of basketball.<br>You have to dance beautifully in the box that you’re comfortable dancing in. My box was to be extremely ambitious within the sport of basketball. Your box is different than mine.<br>Everybody has their own. It’s your job to try to perfect it and make it as beautiful of a canvas as you can make it. And if you have done that, then you have lived a successful life. You have lived with Mamba Mentality.<br>And being married to my wife, Vanessa, is, it’s fun. We have a good time together. I love her tremendously. But we’re best friends too. It’s a blessing. And when we’re raising our daughters one of the things we choose to do is you just got to try your best and you just got to give it your all. Give it everything you have.<br>As parents you’ve have to lead by example. If you want your kids to do whatever it is you want to accomplish in life, you have to show them. I have four girls, so my mission is to make sure women have opportunities. Our daughters will grow up understanding that they can be strong, they can be independent. They can be fierce.<br>I just love spending time with my family and just being a husband, being a father, being a goofball, just having a good time with my kids.<br>I grew up a diehard, I mean, a diehard Laker fan. And to spend 20 years here, I mean you can’t, you can’t write something better than this. Appreciating all this, you know the journey we’ve been on. We’ve been through our ups and we’ve been though our downs.<br>I think the most important part is that we all stayed together throughout. You guys will always be in my heart. Thank you, thank you from the bottom of my heart. God, I love you guys. What can I say? Mamba out.</p>]]></content>
      
      
      
        <tags>
            
            <tag> kobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String</title>
      <link href="2018/11/24/string/"/>
      <url>2018/11/24/string/</url>
      
        <content type="html"><![CDATA[<h4 id="String的特点是什么？它有哪些重要方法？"><a href="#String的特点是什么？它有哪些重要方法？" class="headerlink" title="String的特点是什么？它有哪些重要方法？"></a>String的特点是什么？它有哪些重要方法？</h4><h6 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h6><p>以主流的的JDK8来说，String内部实际存储结构为char的数组，源码如下:</p><pre><code>public final&nbsp;class&nbsp;String   implements&nbsp;java.io.Serializable,&nbsp;Comparable&lt;String&gt;,&nbsp;CharSequence&nbsp;{//&nbsp;用于存储字符串的值&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;char&nbsp;value[];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;缓存字符串的&nbsp;hash&nbsp;code&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;hash;&nbsp;//&nbsp;Default&nbsp;to&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;......其他内容}</code></pre><p>String源码中包含下面几个重要的方法</p><h6 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.  多构造方法"></a>1.  多构造方法</h6><p>String字符串有以下4个重要的构造方法:</p><pre><code>//&nbsp;String&nbsp;为参数的构造方法public&nbsp;String(String&nbsp;original)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;original.value;&nbsp;&nbsp;&nbsp;&nbsp;this.hash&nbsp;=&nbsp;original.hash;}//&nbsp;char[]&nbsp;为参数构造方法public&nbsp;String(char&nbsp;value[])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(value,&nbsp;value.length);}//&nbsp;StringBuffer&nbsp;为参数的构造方法public&nbsp;String(StringBuffer&nbsp;buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;synchronized(buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(buffer.getValue(),&nbsp;buffer.length());&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;StringBuilder&nbsp;为参数的构造方法public&nbsp;String(StringBuilder&nbsp;builder)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(builder.getValue(),&nbsp;builder.length());}</code></pre><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三中数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h6 id="2-equals-比较两个字符串是否相等"><a href="#2-equals-比较两个字符串是否相等" class="headerlink" title="2. &nbsp;equals()比较两个字符串是否相等"></a>2. &nbsp;equals()比较两个字符串是否相等</h6><p>源码如下:</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><p>String类型重写了Object中的equals()方法，equals()方法需要传递一个Object类型的参数值，在比较时会先通过instanceof判断是否为String类型，如果不是则会直接返回false，instanceof的使用如下</p><pre><code>Object&nbsp;oString&nbsp;=&nbsp;"123";Object&nbsp;oInt&nbsp;=&nbsp;123;System.out.println(oString&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;trueSystem.out.println(oInt&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;false</code></pre><p>当判断参数为String类型后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals()比较类似的方法equalslgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p><h6 id="3-compareTo-比较两个字符串"><a href="#3-compareTo-比较两个字符串" class="headerlink" title="3. &nbsp;compareTo()比较两个字符串"></a>3. &nbsp;compareTo()比较两个字符串</h6><p>compareTo()方法用于比较两个字符串，返回的结果为int类型的值，源码如下:</p><pre><code>public&nbsp;int&nbsp;compareTo(String&nbsp;anotherString)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len1&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len2&nbsp;=&nbsp;anotherString.value.length;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取到两个字符串长度最短的那个&nbsp;int&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;lim&nbsp;=&nbsp;Math.min(len1,&nbsp;len2);&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对比每一个字符&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(k&nbsp;&lt;&nbsp;lim)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c1&nbsp;=&nbsp;v1[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c2&nbsp;=&nbsp;v2[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c1&nbsp;!=&nbsp;c2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;有字符不相等就返回差值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c1&nbsp;-&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;len1&nbsp;-&nbsp;len2;}</code></pre><p>从源码可以看出，comapareTo()方法会循环对比所有的字符串，当两个字符串中有人以一个字符不相同时，则return char1 - char2,。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1，返回的值是0，如果存储的是2和1，返回的值是1。 &nbsp;<br>还有一个和compareTo()比较类似的方法compareToLgnoreCase()，用于忽略大小写后比较两个字符串。 &nbsp;<br>可以看出compareTo()方法和equals()方法都适用于比较两个字符串的，但他们有两点不同:</p><ul><li><font color="#0000FF">equals()可以接收一个Object类型的参数，而compareTo()只能接收一个String类型的参数</font> &nbsp;</li><li><font color="#0000FF">equals()返回值为Boolean，而compareTo()的返回值则为int。</font> &nbsp;<br>它们都可以用于两个字符串的比较，当equals()方法返回true时，或者是compareTo()方法返回0时，则表示两个字符串完全相同。  </li></ul><h6 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4. &nbsp;其他重要方法"></a>4. &nbsp;其他重要方法</h6><ul><li><font color="#0000FF">indexOf():查询字符串首次出现的下标位置</font> </li><li><font color="#0000FF">lastIndexOf():查询字符串最后出现的下标位置</font></li><li><font color="#0000FF">contains():查询字符串中是否包含另一个字符串</font> </li><li><font color="#0000FF">toLowerCase():把字符串全部转换成小写</font></li><li><font color="#0000FF">toUpperCase():把字符串全部转换成大写</font></li><li><font color="#0000FF">length():查询字符串的长度</font></li><li><font color="#0000FF">trim():去掉字符串的首尾空格</font></li><li><font color="#0000FF">replace():替换字符串中的某些字符</font></li><li><font color="#0000FF">split():把字符串分割并返回字符串数组</font></li><li><font color="#0000FF">join():把字符串数组转换为字符串</font></li></ul><h6 id="5-和equals-的区别"><a href="#5-和equals-的区别" class="headerlink" title="5. &nbsp;==和equals()的区别"></a>5. &nbsp;==和equals()的区别</h6><p>==对于基本数据类型来说，适用于比较”值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals()方法，源码如下: &nbsp; </p><pre><code>public boolean equals(Object obj){    return (this == obj);}</code></pre><p>可以看出，Object中的equals()方法其实就是==，而String重写了equals()方法把它修改成比较两个字符串的值是否相等。 &nbsp;<br>源码如下：</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><h6 id="6-final修饰的好处"><a href="#6-final修饰的好处" class="headerlink" title="6.  final修饰的好处"></a>6.  final修饰的好处</h6><p>从String类的源码我们可以看出String是被final修饰的不可继承类。<br>那这样设计有什么好处呢？<br>使用final修饰能够缓存结果，当你在传参时不需要考虑谁会修改他的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。 &nbsp;<br>另外一个原因就是因为<strong>安全</strong>，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，他的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。 &nbsp;<br>总结来说，使用final修饰的第一个好处是__安全__；第二个好处是__高效__，以JVM中的字符串常量池举例，如下两个变量:</p><pre><code>String s1 = "java";String s2 = "java";</code></pre><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示:  </p><p><img src="https://github.com/shuaishuai1024/shuaishuai1024.github.io/tree/master/imgs/finalStr.png"></p><p>试想一下如果String是可变的，那当s1的值修改之后，s2的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h6 id="7-String和StringBuffer、StringBuilder的区别"><a href="#7-String和StringBuffer、StringBuilder的区别" class="headerlink" title="7.  String和StringBuffer、StringBuilder的区别"></a>7.  String和StringBuffer、StringBuilder的区别</h6><p>因为String类型是不可变的，所以在字符串拼接的时候如果我们使用的String的话性能会很低，因此我们就需要使用另一个数据类型StringBuffer，他提供了append和insert方法可以用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示:</p><pre><code>@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(Object&nbsp;obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(String.valueOf(obj)); &nbsp;&nbsp;&nbsp;return&nbsp;this;}@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(str);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;}</code></pre><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但他没有使用synchronized来修饰，因此在性能上要优于StringBuffer，所以在非并发环境下可以使用StringBuilder来进行字符串拼接。</p><h6 id="8-String和JVM"><a href="#8-String和JVM" class="headerlink" title="8.  String和JVM"></a>8.  String和JVM</h6><p>String常见的创建方式有两种，new String()的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而new String()的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示:  </p><pre><code>String&nbsp;s1&nbsp;=&nbsp;new&nbsp;String("Java");String&nbsp;s2&nbsp;=&nbsp;s1.intern();String&nbsp;s3&nbsp;=&nbsp;"Java";System.out.println(s1&nbsp;==&nbsp;s2);&nbsp;//&nbsp;falseSystem.out.println(s2&nbsp;==&nbsp;s3);&nbsp;//&nbsp;true</code></pre><p>它们在JVM存储的位置，如下图所示：<br><img src="https://github.com/shuaishuai1024/shuaishuai1024.github.io/tree/master/imgs/jvmStr.png">  </p><blockquote><p>JDK1.7之后把永生代换成了元空间，把字符串常量池从方法区移到了Java堆上</p></blockquote><p>除此之外编译器还会对String字符串做一些优化，例如以下代码:</p><pre><code>String s1 = "ja" + "va";String s2 = "java";System.out.println(s1 == s2);</code></pre><p>虽然s1拼接了多个字符串，但对比的结果确实true，我们使用反编译工具，看到的结果如下：</p><pre><code>Compiled&nbsp;from&nbsp;"StringExample.java"public&nbsp;class&nbsp;com.lagou.interview.StringExample&nbsp;{&nbsp;&nbsp;public&nbsp;com.lagou.interview.StringExample();&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;invokespecial&nbsp;#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/lang/Object."&lt;init&gt;":()V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;3:&nbsp;0&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(java.lang.String[]);&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;astore_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;astore_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;getstatic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Field&nbsp;java/lang/System.out:Ljava/io/PrintStream;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9:&nbsp;aload_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;aload_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11:&nbsp;if_acmpne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14:&nbsp;iconst_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15:&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18:&nbsp;iconst_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19:&nbsp;invokevirtual&nbsp;#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/io/PrintStream.println:(Z)V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;5:&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;6:&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;7:&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;8:&nbsp;22}</code></pre><p>从编译代码#2可以看出，代码”Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是true，这就是编译器对字符串优化的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
