<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>This for basketball</title>
      <link href="2020/11/18/basketball/"/>
      <url>2020/11/18/basketball/</url>
      
        <content type="html"><![CDATA[<p>Once upon a time there was a young basketball player who had dreams of becoming one of the greatest basketball players of all-time.  </p><a id="more"></a>  <p>He had the opportunity to go to the NBA and play against the greatest players in the world. If that doesn’t get you going, I don’t think anything will.<br>It’s like a dream come true.<br>I couldn’t even dream of this when I was a kid. You know. Just no way possible. It’s just, you know, just a blessing from above.<br>The joy of the game comes from just being out there and just playing. The competitive side of me thinks we can win every game that we play.<br>What I’ve learned is to … always keep going.<br>Do you love the process? That gets you to that. Those boring, agonizing moments. If you love that, then you know you found something that’s really true to you.<br>You know, if you do the work, you work hard enough, dreams come true. Those times when you get up early and you work hard. Those times when you stay up late and you work hard. Those times when you don’t feel like working, you’re too tired, you don’t want to push yourself, but you do it anyway. That is actually the dream.<br>If you’re a fan of mine, you’re a fan of winning. You’re fan of the Lakers. That’s never going to change.<br>Man, I gave my soul to this game. There was nothing more I could give.<br>I wanted to be one of the best basketball players to ever play and anything else that was outside of that lane, I didn’t have time for.<br>It’s not about my jerseys that are hanging up there for me. It’s about the jerseys that were hanging up there before.<br>Growing up and watching all these great players play and learning so much from them. To now be a part of that wall, you know, means everything to me.<br>When you get older you start to understand that really it’s about the next generation. That these championships do come and go. But the most important thing you can do is to pay everything that you’ve learned forward to the next generation to come. And that’s truly how you create something that lasts forever.<br>I love storytelling. Can you imagine, like, winning an Oscar, how ridiculous that would be?Unfortunately for us athletes, we’ve been pigeonholed into thinking that we can only be one thing.<br>I’m here to show people that we can do much more than that. Winning an Oscar, winning an Emmy and an Annie, those are things that are showing other athletes that come after, no, no, there’s more to this thing.<br>The discipline, the commitment, the team, the community. How do I take those lessons and move those here? Having that sharp focus is something that I got from the game of basketball.<br>You have to dance beautifully in the box that you’re comfortable dancing in. My box was to be extremely ambitious within the sport of basketball. Your box is different than mine.<br>Everybody has their own. It’s your job to try to perfect it and make it as beautiful of a canvas as you can make it. And if you have done that, then you have lived a successful life. You have lived with Mamba Mentality.<br>And being married to my wife, Vanessa, is, it’s fun. We have a good time together. I love her tremendously. But we’re best friends too. It’s a blessing. And when we’re raising our daughters one of the things we choose to do is you just got to try your best and you just got to give it your all. Give it everything you have.<br>As parents you’ve have to lead by example. If you want your kids to do whatever it is you want to accomplish in life, you have to show them. I have four girls, so my mission is to make sure women have opportunities. Our daughters will grow up understanding that they can be strong, they can be independent. They can be fierce.<br>I just love spending time with my family and just being a husband, being a father, being a goofball, just having a good time with my kids.<br>I grew up a diehard, I mean, a diehard Laker fan. And to spend 20 years here, I mean you can’t, you can’t write something better than this. Appreciating all this, you know the journey we’ve been on. We’ve been through our ups and we’ve been though our downs.<br>I think the most important part is that we all stayed together throughout. You guys will always be in my heart. Thank you, thank you from the bottom of my heart. God, I love you guys. What can I say? Mamba out.</p>]]></content>
      
      
      <categories>
          
          <category> basketball </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 的8种用法</title>
      <link href="2020/11/10/synchronized-use/"/>
      <url>2020/11/10/synchronized-use/</url>
      
        <content type="html"><![CDATA[<h6 id="八种使用场景"><a href="#八种使用场景" class="headerlink" title="八种使用场景"></a><font color="blue">八种使用场景</font></h6><a id="more"></a> &nbsp;<ol><li>两个线程同时访问同一个对象的同步方法  </li><li>两个线程同时访问两个对象的同步方法  </li><li>两个线程同时访问(一个或两个)对象的静态同步方法  </li><li>两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法  </li><li>两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法  </li><li>两个线程同时访问同一个对象的不同的同步方法  </li><li>两个线程分别同时访问静态synchronized和非静态synchronized方法  </li><li>同步方法抛出异常后，JVM会自动释放锁的情况 &nbsp;</li></ol><hr><p><font color="#0000FF">场景一：两个线程同时访问同一个对象的同步方法</font> </p><hr><p>分析：这种情况是经典的对象锁中的方法锁，两个线程争夺同一个对象锁，所以会相互等待，是线程安全的。<br><font color="#7FFFD4" size="3px">「两个线程同时访问同一个对象的同步方法，是线程安全的。」</font> &nbsp;</p><hr><p><font color="#0000FF">场景二：两个线程同时访问同一个对象的同步方法</font> &nbsp;</p><hr><p>这种场景就是对象锁失效的场景，原因出在访问的是两个对象的同步方法，那么这两个线程分别持有的两个线程的锁，所以是互相不会受限的。加锁的目的是为了让多个线程竞争同一把锁，而这种情况多个线程之间不再竞争同一把锁，而是分别持有一把锁，所以我们的结论是： &nbsp;<br><font color="#7FFFD4" size="3">「两个线程同时访问两个对象的同步方法，是线程不安全的。」</font><br><font color="#7FFFD4" size="3">&lt;/&gt;</font>代码验证：  </p><pre><code>public class Condition2 implements Runnable {      // 创建两个不同的对象    static Condition2 instance1 = new Condition2();    static Condition2 instance2 = new Condition2();    @Override    public void run() {      method();    }    private synchronized void method() {    System.out.println("线程名：" +       Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance1);    Thread thread2 = new Thread(instance2);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4" size="3">&lt;/&gt;</font>运行结果： &nbsp;<br>两个线程是并行执行的，所以线程不安全。  </p><pre><code>线程名：Thread-0,运行开始线程名：Thread-1,运行开始线程名：Thread-0,运行结束线程名：Thread-1,运行结束测试结束</code></pre><p><font color="#7FFFD4" size="3">&lt;/&gt;</font>代码分析：<br><font color="#7FFFD4" size="3">「问题在此：」</font> &nbsp;<br>两个线程(thread1，thread2)，访问两个对象(instance1、instance2)的同步方法（method()），两个线程都有各自的锁，不能形成两个线程竞争一把锁的局势，所以这时，synchronized<br>修饰的方法method()和不用synchronized修饰的效果一样(不信可以把synchronized关键字去掉，运行结果一样)，所以此时的method()只是个普通方法。   </p><p><font color="#7FFFD4" size="3">「如何解决这个问题：」</font></p><p>若要使锁生效，只需要将method()方法用static修饰，这样就形成了类锁，多个实例(instance1、instance2)共同竞争同一把类锁，就可以使两个线程串行执行了。这也就是下一个场景要讲的内容。 &nbsp;</p><hr><p><font color="#0000FF">场景三：两个线程同时访问(一个或两个)对象的静态同步方法</font> &nbsp;</p><hr><p>这个场景解决的是场景二中出现的线程不安全问题，即用类锁实现: &nbsp;<br><font color="#7FFFD4" size="3">「两个线程同时访问(一个或两个)对象的静态同步方法，是线程安全的」</font> &nbsp;</p><hr><p><font color="#0000FF">场景四：两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法</font> &nbsp; &nbsp; &nbsp;</p><hr><p>这个场景是两个线程其中一个访问同步方法，另一个访问非同步方法，此时线程会不会串行执行呢，也就是说是不是线程安全的呢？ &nbsp;<br>我们可以确定是线程不安全的，如果方法不加<font color="#7FFFD4">synchronized</font>都是安全的，那就不需要同步方法了。 &nbsp;<br>验证下我们的结论：<br><font color="#7FFFD4" size="3">「两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法，是线程不安全的」</font></p><pre><code>public class Condition4 implements Runnable {   static Condition4 instance = new Condition4();   @Override   public void run() {    //两个线程访问同步方法和非同步方法    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行非同步方法method1()     method1();    }   }      // 同步方法   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法，运行结束");   }      // 普通方法   private void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，普通方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，普通方法，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  } </code></pre><p><font color="#7FFFD4">&lt;/&gt;运行结果：</font> &nbsp;<br>两个线程是并行执行的，所以是线程不安全的。  </p><pre><code>线程名：Thread-0，同步方法，运行开始  线程名：Thread-1，普通方法，运行开始  线程：Thread-0，同步方法，运行结束  线程：Thread-1，普通方法，运行结束  测试结束 </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>结果分析：  &nbsp;<br>问题在于此：method1没有被synchronized修饰，所以当然不会受到锁的影响。即便是在同一个对象中，当然在多个实例中，更不会被锁影响了。结论：<br><font color="#7FFFD4" size="3">「非同步方法不受其他由synchronized修饰的同步方法的影响」</font> &nbsp;<br>你可能想到一个类似场景：多个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法，这个场景会是线程安全的吗？</p><hr><p><font color="#0000FF">场景五：两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法</font> &nbsp; &nbsp; &nbsp;</p><hr><p>我们来实验一下这个场景，用两个线程调用同步方法，在同步方法中调用普通方法；再用一个线程直接调用普通方法，看看是否是线程安全的？  </p><pre><code>public class Condition8 implements Runnable {   static Condition8 instance = new Condition8();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //直接调用普通方法     method2();    } else {     // 先调用同步方法，在同步方法内调用普通方法     method1();    }   }   // 同步方法   private static synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法，运行开始");    try {     Thread.sleep(2000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法，运行结束,开始调用普通方法");    method2();   }   // 普通方法   private static void method2() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，普通方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，普通方法，运行结束");   }   public static void main(String[] args) {    // 此线程直接调用普通方法    Thread thread0 = new Thread(instance);    // 这两个线程直接调用同步方法    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread0.start();    thread1.start();    thread2.start();    while (thread0.isAlive() || thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }</code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>运行结果：  </p><pre><code>线程名：Thread-0，普通方法，运行开始  线程名：Thread-1，同步方法，运行开始  线程：Thread-1，同步方法，运行结束,开始调用普通方法  线程名：Thread-1，普通方法，运行开始  线程：Thread-0，普通方法，运行结束  线程：Thread-1，普通方法，运行结束  线程名：Thread-2，同步方法，运行开始  线程：Thread-2，同步方法，运行结束,开始调用普通方法  线程名：Thread-2，普通方法，运行开始  线程：Thread-2，普通方法，运行结束  测试结束</code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>结果分析: &nbsp;<br>我们可以看出，普通方法被两个线程并行执行，不是线程安全的。这是为什么呢？ &nbsp;<br>因为如果非同步方法，有任何其它线程直接调用，而不是仅在调用同步方法，才调用非同步方法，此时会出现多个线程并行执行非同步方法的情况，线程就不安全了。 &nbsp;<br>对于同步方法中调用非同步方法时，要想保证线程安全，就必须保证非同步方法的入口，仅出现在同步方法中。但这种控制方式不够优雅，若被不明情况的人直接调用非同步方法，就会导致原有的线程同步不再安全。所以不推荐大家在项目中这样使用，但我们要理解这种情况，并且我们要用语义明确的、让人一看就知道这是同步方法的方式，来处理线程安全的问题。 &nbsp;<br>所以，最简单的方式，是在非同步方法上，也加上<code>synchronized</code>关键字，使其变成一个同步方法，这样就变成了《场景五：两个线程同时访问同一个对象的不同的同步方法》，这种场景下，大家就很清楚的看到，同一个对象中的两个同步方法，不管那个线程调用，都是线程安全的了。 &nbsp;<br>所以结论是：<br><font color="#7FFFD4">「两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法，仅在没有其他线程直接调用非同步方法的情况下，是线程安全的。若有其他线程直接调用非同步方法，则是线程不安全的。」</font> &nbsp;</p><hr><p><font color="#0000FF">场景六：两个线程同时访问同一个对象的不同的同步方法</font> &nbsp;</p><hr><p>这个场景也是在探讨对象锁的作用范围，对象锁的作用范围是对象中的所有同步方法。所以，当访问同一个对象中的多个同步方法时，结论是:  </p><p><font color="#…FFFD4" size="3">「两个对象同时访问同一个对象的不同的同步方法时，是线程安全的。」</font>  </p><pre><code>public class Condition5 implements Runnable {   static Condition5 instance = new Condition5();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行同步方法method1()     method1();    }   }   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法0，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法0，运行结束");   }   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法1，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法1，运行结束");   }   //运行结果:串行   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>运行结果: &nbsp;<br>是线程安全的。  </p><pre><code>线程名：Thread-1，同步方法1，运行开始  线程：Thread-1，同步方法1，运行结束  线程名：Thread-0，同步方法0，运行开始  线程：Thread-0，同步方法0，运行结束  测试结束  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>结果分析:</strong> &nbsp;<br>两个方法(method0()和method1())的synchronized修饰符，虽没有指定锁对象，但默认所对象为this对象为锁对象，所以对于同一个实例(instance)，两个线程拿到的锁是同一把锁，此时同步方法会串行执行。这也是synchronized关键字的可重入的一种体现。  </p><hr><p><font color="#0000FF">场景七：两个线程分别同时访问静态synchronized和非静态synchronized方法</font>  </p><hr><p>这种场景的本质也是在探讨两个线程获取的是不是同一把锁得问题。静态<font color="#7FFFD4">synchronized</font>方法属于类锁，所对象是<font color="#7FFFD4">(*.class)</font>对象，非静态<font color="#7FFFD4">synchronized</font>方法属于对象锁中的方法锁，所对象是<font color="#7FFFD4">this</font>对象。两个线程拿到的是不同的锁，自然不会相互影响。结论：  </p><p><font color="#7FFFD4" size="3">「两个线程分别同时访问静态synchronized和非静态synchronized方法，线程不安全。」</font> &nbsp;</p><p><font color="#7FFFD4">&lt;/&gt;</font><strong>代码实现:</strong>  </p><pre><code>public class Condition6 implements Runnable {   static Condition6 instance = new Condition6();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行静态同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行非静态同步方法method1()     method1();    }   }   // 重点：用static synchronized 修饰的方法，属于类锁，锁对象为（*.class）对象。   private static synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，静态同步方法0，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，静态同步方法0，运行结束");   }   // 重点：synchronized 修饰的方法，属于方法锁，锁对象为（this）对象。   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，非静态同步方法1，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，非静态同步方法1，运行结束");   }   //运行结果:并行   public static void main(String[] args) {    //问题原因： 线程1的锁是类锁（*.class）对象，线程2的锁是方法锁（this）对象,两个线程的锁不一样，自然不会互相影响，所以会并行执行。    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>运行结果:</strong>  </p><pre><code>线程名：Thread-0，静态同步方法0，运行开始  线程名：Thread-1，非静态同步方法1，运行开始  线程：Thread-1，非静态同步方法1，运行结束  线程：Thread-0，静态同步方法0，运行结束  测试结束 </code></pre><hr><p><font color="#0000FF">场景八：同步方法抛出异常后，JVM会自动释放锁的情况</font>  </p><hr><p>本场景讨论的是<font coloe="#7FFFD4">synchronized</font>释放锁的场景：  </p><p><font color="#…FFFD4" size="3">「只有当同步方法执行完或执行时抛出异常这两种情况，才会释放锁。」</font>  </p><p>所以，在一个线程同步方法中出现异常的时候，会释放锁，另一个线程得到锁，继续执行。而不会出现一个线程抛出异常后，另一个线程一直等待获取锁的情况。这是因为JVM在同步方法抛出异常的时候，会自动释放锁对象。<br><font color="#7FFFD4">&lt;/&gt;</font><strong>代码实现：</strong>  </p><pre><code>public class Condition7 implements Runnable {   private static Condition7 instance = new Condition7();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行抛异常方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行正常方法method1()     method1();    }   }   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    //同步方法中，当抛出异常时，JVM会自动释放锁，不需要手动释放，其他线程即可获取到该锁    System.out.println("线程名：" + Thread.currentThread().getName() + "，抛出异常，释放锁");    throw new RuntimeException();   }   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>运行结果：</strong>  </p><pre><code>线程名：Thread-0，运行开始  线程名：Thread-0，抛出异常，释放锁  线程名：Thread-1，运行开始  Exception in thread "Thread-0" java.lang.RuntimeException   at com.study.synchronize.conditions.Condition7.method0(Condition7.java:34)   at com.study.synchronize.conditions.Condition7.run(Condition7.java:17)   at java.lang.Thread.run(Thread.java:748)  线程：Thread-1，运行结束  测试结束  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>结果分析：</strong> &nbsp;<br>可以看出线程还是串行执行的，说明是线程安全的。而且出现异常后，不会造成死锁现象，JVM会自动释放出现异常线程的所对象，其他线程获取锁继续执行。  </p><hr><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>本文总结了并用代码实现和验证了<font color="#7FFFD4">synchronized</font>各种使用场景，以及各种场景发生的原因和结论。我们分析的理论基础都是<font color="#7FFFD4">synchronized</font>关键字的锁对象究竟是谁？多个线程之间是否竞争同一把锁？根据这个条件来判断线程是否是安全的。所以，有了这些场景的分析锻炼后，我们在以后使用多线程编程时，也可以通过分析锁对象的方式，判断出线程是否是安全的，从而避免此类问题的出现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String</title>
      <link href="2018/11/24/string/"/>
      <url>2018/11/24/string/</url>
      
        <content type="html"><![CDATA[<h4 id="String的特点是什么？它有哪些重要方法？"><a href="#String的特点是什么？它有哪些重要方法？" class="headerlink" title="String的特点是什么？它有哪些重要方法？ &nbsp;"></a>String的特点是什么？它有哪些重要方法？ &nbsp;</h4><a id="more"></a>  <h6 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h6><p>以主流的的JDK8来说，String内部实际存储结构为char的数组，源码如下:</p><pre><code>public final&nbsp;class&nbsp;String   implements&nbsp;java.io.Serializable,&nbsp;Comparable&lt;String&gt;,&nbsp;CharSequence&nbsp;{//&nbsp;用于存储字符串的值&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;char&nbsp;value[];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;缓存字符串的&nbsp;hash&nbsp;code&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;hash;&nbsp;//&nbsp;Default&nbsp;to&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;......其他内容}</code></pre><p>String源码中包含下面几个重要的方法</p><h6 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.  多构造方法"></a>1.  多构造方法</h6><p>String字符串有以下4个重要的构造方法:</p><pre><code>//&nbsp;String&nbsp;为参数的构造方法public&nbsp;String(String&nbsp;original)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;original.value;&nbsp;&nbsp;&nbsp;&nbsp;this.hash&nbsp;=&nbsp;original.hash;}//&nbsp;char[]&nbsp;为参数构造方法public&nbsp;String(char&nbsp;value[])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(value,&nbsp;value.length);}//&nbsp;StringBuffer&nbsp;为参数的构造方法public&nbsp;String(StringBuffer&nbsp;buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;synchronized(buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(buffer.getValue(),&nbsp;buffer.length());&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;StringBuilder&nbsp;为参数的构造方法public&nbsp;String(StringBuilder&nbsp;builder)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(builder.getValue(),&nbsp;builder.length());}</code></pre><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三中数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h6 id="2-equals-比较两个字符串是否相等"><a href="#2-equals-比较两个字符串是否相等" class="headerlink" title="2. &nbsp;equals()比较两个字符串是否相等"></a>2. &nbsp;equals()比较两个字符串是否相等</h6><p>源码如下:</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><p>String类型重写了Object中的equals()方法，equals()方法需要传递一个Object类型的参数值，在比较时会先通过instanceof判断是否为String类型，如果不是则会直接返回false，instanceof的使用如下</p><pre><code>Object&nbsp;oString&nbsp;=&nbsp;"123";Object&nbsp;oInt&nbsp;=&nbsp;123;System.out.println(oString&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;trueSystem.out.println(oInt&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;false</code></pre><p>当判断参数为String类型后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals()比较类似的方法equalslgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p><h6 id="3-compareTo-比较两个字符串"><a href="#3-compareTo-比较两个字符串" class="headerlink" title="3. &nbsp;compareTo()比较两个字符串"></a>3. &nbsp;compareTo()比较两个字符串</h6><p>compareTo()方法用于比较两个字符串，返回的结果为int类型的值，源码如下:</p><pre><code>public&nbsp;int&nbsp;compareTo(String&nbsp;anotherString)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len1&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len2&nbsp;=&nbsp;anotherString.value.length;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取到两个字符串长度最短的那个&nbsp;int&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;lim&nbsp;=&nbsp;Math.min(len1,&nbsp;len2);&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对比每一个字符&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(k&nbsp;&lt;&nbsp;lim)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c1&nbsp;=&nbsp;v1[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c2&nbsp;=&nbsp;v2[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c1&nbsp;!=&nbsp;c2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;有字符不相等就返回差值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c1&nbsp;-&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;len1&nbsp;-&nbsp;len2;}</code></pre><p>从源码可以看出，comapareTo()方法会循环对比所有的字符串，当两个字符串中有人以一个字符不相同时，则return char1 - char2,。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1，返回的值是0，如果存储的是2和1，返回的值是1。 &nbsp;<br>还有一个和compareTo()比较类似的方法compareToLgnoreCase()，用于忽略大小写后比较两个字符串。 &nbsp;<br>可以看出compareTo()方法和equals()方法都适用于比较两个字符串的，但他们有两点不同:</p><ul><li><font color="#0000FF">equals()可以接收一个Object类型的参数，而compareTo()只能接收一个String类型的参数</font> &nbsp;</li><li><font color="#0000FF">equals()返回值为Boolean，而compareTo()的返回值则为int。</font> &nbsp;<br>它们都可以用于两个字符串的比较，当equals()方法返回true时，或者是compareTo()方法返回0时，则表示两个字符串完全相同。  </li></ul><h6 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4. &nbsp;其他重要方法"></a>4. &nbsp;其他重要方法</h6><ul><li><font color="#0000FF">indexOf():查询字符串首次出现的下标位置</font> </li><li><font color="#0000FF">lastIndexOf():查询字符串最后出现的下标位置</font></li><li><font color="#0000FF">contains():查询字符串中是否包含另一个字符串</font> </li><li><font color="#0000FF">toLowerCase():把字符串全部转换成小写</font></li><li><font color="#0000FF">toUpperCase():把字符串全部转换成大写</font></li><li><font color="#0000FF">length():查询字符串的长度</font></li><li><font color="#0000FF">trim():去掉字符串的首尾空格</font></li><li><font color="#0000FF">replace():替换字符串中的某些字符</font></li><li><font color="#0000FF">split():把字符串分割并返回字符串数组</font></li><li><font color="#0000FF">join():把字符串数组转换为字符串</font></li></ul><h6 id="5-和equals-的区别"><a href="#5-和equals-的区别" class="headerlink" title="5. &nbsp;==和equals()的区别"></a>5. &nbsp;==和equals()的区别</h6><p>==对于基本数据类型来说，适用于比较”值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals()方法，源码如下: &nbsp; </p><pre><code>public boolean equals(Object obj){    return (this == obj);}</code></pre><p>可以看出，Object中的equals()方法其实就是==，而String重写了equals()方法把它修改成比较两个字符串的值是否相等。 &nbsp;<br>源码如下：</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><h6 id="6-final修饰的好处"><a href="#6-final修饰的好处" class="headerlink" title="6.  final修饰的好处"></a>6.  final修饰的好处</h6><p>从String类的源码我们可以看出String是被final修饰的不可继承类。<br>那这样设计有什么好处呢？<br>使用final修饰能够缓存结果，当你在传参时不需要考虑谁会修改他的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。 &nbsp;<br>另外一个原因就是因为<strong>安全</strong>，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，他的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。 &nbsp;<br>总结来说，使用final修饰的第一个好处是__安全__；第二个好处是__高效__，以JVM中的字符串常量池举例，如下两个变量:</p><pre><code>String s1 = "java";String s2 = "java";</code></pre><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示:  </p><p><img src="/img/finalStr.png"></p><p>试想一下如果String是可变的，那当s1的值修改之后，s2的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h6 id="7-String和StringBuffer、StringBuilder的区别"><a href="#7-String和StringBuffer、StringBuilder的区别" class="headerlink" title="7.  String和StringBuffer、StringBuilder的区别"></a>7.  String和StringBuffer、StringBuilder的区别</h6><p>因为String类型是不可变的，所以在字符串拼接的时候如果我们使用的String的话性能会很低，因此我们就需要使用另一个数据类型StringBuffer，他提供了append和insert方法可以用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示:</p><pre><code>@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(Object&nbsp;obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(String.valueOf(obj)); &nbsp;&nbsp;&nbsp;return&nbsp;this;}@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(str);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;}</code></pre><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但他没有使用synchronized来修饰，因此在性能上要优于StringBuffer，所以在非并发环境下可以使用StringBuilder来进行字符串拼接。</p><h6 id="8-String和JVM"><a href="#8-String和JVM" class="headerlink" title="8.  String和JVM"></a>8.  String和JVM</h6><p>String常见的创建方式有两种，new String()的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而new String()的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示:  </p><pre><code>String&nbsp;s1&nbsp;=&nbsp;new&nbsp;String("Java");String&nbsp;s2&nbsp;=&nbsp;s1.intern();String&nbsp;s3&nbsp;=&nbsp;"Java";System.out.println(s1&nbsp;==&nbsp;s2);&nbsp;//&nbsp;falseSystem.out.println(s2&nbsp;==&nbsp;s3);&nbsp;//&nbsp;true</code></pre><p>它们在JVM存储的位置，如下图所示：<br><img src="/img/jvmStr.png">  </p><blockquote><p>JDK1.7之后把永生代换成了元空间，把字符串常量池从方法区移到了Java堆上</p></blockquote><p>除此之外编译器还会对String字符串做一些优化，例如以下代码:</p><pre><code>String s1 = "ja" + "va";String s2 = "java";System.out.println(s1 == s2);</code></pre><p>虽然s1拼接了多个字符串，但对比的结果确实true，我们使用反编译工具，看到的结果如下：</p><pre><code>Compiled&nbsp;from&nbsp;"StringExample.java"public&nbsp;class&nbsp;com.lagou.interview.StringExample&nbsp;{&nbsp;&nbsp;public&nbsp;com.lagou.interview.StringExample();&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;invokespecial&nbsp;#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/lang/Object."&lt;init&gt;":()V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;3:&nbsp;0&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(java.lang.String[]);&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;astore_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;astore_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;getstatic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Field&nbsp;java/lang/System.out:Ljava/io/PrintStream;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9:&nbsp;aload_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;aload_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11:&nbsp;if_acmpne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14:&nbsp;iconst_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15:&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18:&nbsp;iconst_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19:&nbsp;invokevirtual&nbsp;#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/io/PrintStream.println:(Z)V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;5:&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;6:&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;7:&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;8:&nbsp;22}</code></pre><p>从编译代码#2可以看出，代码”Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是true，这就是编译器对字符串优化的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
