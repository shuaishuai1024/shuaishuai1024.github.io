<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>This for basketball</title>
      <link href="2020/11/18/basketball/"/>
      <url>2020/11/18/basketball/</url>
      
        <content type="html"><![CDATA[<p>Once upon a time there was a young basketball player who had dreams of becoming one of the greatest basketball players of all-time.  </p><a id="more"></a>  <p>He had the opportunity to go to the NBA and play against the greatest players in the world. If that doesn’t get you going, I don’t think anything will.<br>It’s like a dream come true.<br>I couldn’t even dream of this when I was a kid. You know. Just no way possible. It’s just, you know, just a blessing from above.<br>The joy of the game comes from just being out there and just playing. The competitive side of me thinks we can win every game that we play.<br>What I’ve learned is to … always keep going.<br>Do you love the process? That gets you to that. Those boring, agonizing moments. If you love that, then you know you found something that’s really true to you.<br>You know, if you do the work, you work hard enough, dreams come true. Those times when you get up early and you work hard. Those times when you stay up late and you work hard. Those times when you don’t feel like working, you’re too tired, you don’t want to push yourself, but you do it anyway. That is actually the dream.<br>If you’re a fan of mine, you’re a fan of winning. You’re fan of the Lakers. That’s never going to change.<br>Man, I gave my soul to this game. There was nothing more I could give.<br>I wanted to be one of the best basketball players to ever play and anything else that was outside of that lane, I didn’t have time for.<br>It’s not about my jerseys that are hanging up there for me. It’s about the jerseys that were hanging up there before.<br>Growing up and watching all these great players play and learning so much from them. To now be a part of that wall, you know, means everything to me.<br>When you get older you start to understand that really it’s about the next generation. That these championships do come and go. But the most important thing you can do is to pay everything that you’ve learned forward to the next generation to come. And that’s truly how you create something that lasts forever.<br>I love storytelling. Can you imagine, like, winning an Oscar, how ridiculous that would be?Unfortunately for us athletes, we’ve been pigeonholed into thinking that we can only be one thing.<br>I’m here to show people that we can do much more than that. Winning an Oscar, winning an Emmy and an Annie, those are things that are showing other athletes that come after, no, no, there’s more to this thing.<br>The discipline, the commitment, the team, the community. How do I take those lessons and move those here? Having that sharp focus is something that I got from the game of basketball.<br>You have to dance beautifully in the box that you’re comfortable dancing in. My box was to be extremely ambitious within the sport of basketball. Your box is different than mine.<br>Everybody has their own. It’s your job to try to perfect it and make it as beautiful of a canvas as you can make it. And if you have done that, then you have lived a successful life. You have lived with Mamba Mentality.<br>And being married to my wife, Vanessa, is, it’s fun. We have a good time together. I love her tremendously. But we’re best friends too. It’s a blessing. And when we’re raising our daughters one of the things we choose to do is you just got to try your best and you just got to give it your all. Give it everything you have.<br>As parents you’ve have to lead by example. If you want your kids to do whatever it is you want to accomplish in life, you have to show them. I have four girls, so my mission is to make sure women have opportunities. Our daughters will grow up understanding that they can be strong, they can be independent. They can be fierce.<br>I just love spending time with my family and just being a husband, being a father, being a goofball, just having a good time with my kids.<br>I grew up a diehard, I mean, a diehard Laker fan. And to spend 20 years here, I mean you can’t, you can’t write something better than this. Appreciating all this, you know the journey we’ve been on. We’ve been through our ups and we’ve been though our downs.<br>I think the most important part is that we all stayed together throughout. You guys will always be in my heart. Thank you, thank you from the bottom of my heart. God, I love you guys. What can I say? Mamba out.</p>]]></content>
      
      
      <categories>
          
          <category> basketball </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 的8种用法</title>
      <link href="2020/11/10/synchronized-use/"/>
      <url>2020/11/10/synchronized-use/</url>
      
        <content type="html"><![CDATA[<h6 id="八种使用场景"><a href="#八种使用场景" class="headerlink" title="八种使用场景"></a><font color="blue">八种使用场景</font></h6><a id="more"></a> &nbsp;<ol><li>两个线程同时访问同一个对象的同步方法  </li><li>两个线程同时访问两个对象的同步方法  </li><li>两个线程同时访问(一个或两个)对象的静态同步方法  </li><li>两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法  </li><li>两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法  </li><li>两个线程同时访问同一个对象的不同的同步方法  </li><li>两个线程分别同时访问静态synchronized和非静态synchronized方法  </li><li>同步方法抛出异常后，JVM会自动释放锁的情况 &nbsp;</li></ol><hr><p><font color="#0000FF">场景一：两个线程同时访问同一个对象的同步方法</font> </p><hr><p>分析：这种情况是经典的对象锁中的方法锁，两个线程争夺同一个对象锁，所以会相互等待，是线程安全的。<br><font color="#7FFFD4" size="3px">「两个线程同时访问同一个对象的同步方法，是线程安全的。」</font> &nbsp;</p><hr><p><font color="#0000FF">场景二：两个线程同时访问同一个对象的同步方法</font> &nbsp;</p><hr><p>这种场景就是对象锁失效的场景，原因出在访问的是两个对象的同步方法，那么这两个线程分别持有的两个线程的锁，所以是互相不会受限的。加锁的目的是为了让多个线程竞争同一把锁，而这种情况多个线程之间不再竞争同一把锁，而是分别持有一把锁，所以我们的结论是： &nbsp;<br><font color="#7FFFD4" size="3">「两个线程同时访问两个对象的同步方法，是线程不安全的。」</font><br><font color="#7FFFD4" size="3">&lt;/&gt;</font>代码验证：  </p><pre><code>public class Condition2 implements Runnable {      // 创建两个不同的对象    static Condition2 instance1 = new Condition2();    static Condition2 instance2 = new Condition2();    @Override    public void run() {      method();    }    private synchronized void method() {    System.out.println("线程名：" +       Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance1);    Thread thread2 = new Thread(instance2);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4" size="3">&lt;/&gt;</font>运行结果： &nbsp;<br>两个线程是并行执行的，所以线程不安全。  </p><pre><code>线程名：Thread-0,运行开始线程名：Thread-1,运行开始线程名：Thread-0,运行结束线程名：Thread-1,运行结束测试结束</code></pre><p><font color="#7FFFD4" size="3">&lt;/&gt;</font>代码分析：<br><font color="#7FFFD4" size="3">「问题在此：」</font> &nbsp;<br>两个线程(thread1，thread2)，访问两个对象(instance1、instance2)的同步方法（method()），两个线程都有各自的锁，不能形成两个线程竞争一把锁的局势，所以这时，synchronized<br>修饰的方法method()和不用synchronized修饰的效果一样(不信可以把synchronized关键字去掉，运行结果一样)，所以此时的method()只是个普通方法。   </p><p><font color="#7FFFD4" size="3">「如何解决这个问题：」</font></p><p>若要使锁生效，只需要将method()方法用static修饰，这样就形成了类锁，多个实例(instance1、instance2)共同竞争同一把类锁，就可以使两个线程串行执行了。这也就是下一个场景要讲的内容。 &nbsp;</p><hr><p><font color="#0000FF">场景三：两个线程同时访问(一个或两个)对象的静态同步方法</font> &nbsp;</p><hr><p>这个场景解决的是场景二中出现的线程不安全问题，即用类锁实现: &nbsp;<br><font color="#7FFFD4" size="3">「两个线程同时访问(一个或两个)对象的静态同步方法，是线程安全的」</font> &nbsp;</p><hr><p><font color="#0000FF">场景四：两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法</font> &nbsp; &nbsp; &nbsp;</p><hr><p>这个场景是两个线程其中一个访问同步方法，另一个访问非同步方法，此时线程会不会串行执行呢，也就是说是不是线程安全的呢？ &nbsp;<br>我们可以确定是线程不安全的，如果方法不加<font color="#7FFFD4">synchronized</font>都是安全的，那就不需要同步方法了。 &nbsp;<br>验证下我们的结论：<br><font color="#7FFFD4" size="3">「两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法，是线程不安全的」</font></p><pre><code>public class Condition4 implements Runnable {   static Condition4 instance = new Condition4();   @Override   public void run() {    //两个线程访问同步方法和非同步方法    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行非同步方法method1()     method1();    }   }      // 同步方法   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法，运行结束");   }      // 普通方法   private void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，普通方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，普通方法，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  } </code></pre><p><font color="#7FFFD4">&lt;/&gt;运行结果：</font> &nbsp;<br>两个线程是并行执行的，所以是线程不安全的。  </p><pre><code>线程名：Thread-0，同步方法，运行开始  线程名：Thread-1，普通方法，运行开始  线程：Thread-0，同步方法，运行结束  线程：Thread-1，普通方法，运行结束  测试结束 </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>结果分析：  &nbsp;<br>问题在于此：method1没有被synchronized修饰，所以当然不会受到锁的影响。即便是在同一个对象中，当然在多个实例中，更不会被锁影响了。结论：<br><font color="#7FFFD4" size="3">「非同步方法不受其他由synchronized修饰的同步方法的影响」</font> &nbsp;<br>你可能想到一个类似场景：多个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法，这个场景会是线程安全的吗？</p><hr><p><font color="#0000FF">场景五：两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法</font> &nbsp; &nbsp; &nbsp;</p><hr><p>我们来实验一下这个场景，用两个线程调用同步方法，在同步方法中调用普通方法；再用一个线程直接调用普通方法，看看是否是线程安全的？  </p><pre><code>public class Condition8 implements Runnable {   static Condition8 instance = new Condition8();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //直接调用普通方法     method2();    } else {     // 先调用同步方法，在同步方法内调用普通方法     method1();    }   }   // 同步方法   private static synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法，运行开始");    try {     Thread.sleep(2000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法，运行结束,开始调用普通方法");    method2();   }   // 普通方法   private static void method2() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，普通方法，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，普通方法，运行结束");   }   public static void main(String[] args) {    // 此线程直接调用普通方法    Thread thread0 = new Thread(instance);    // 这两个线程直接调用同步方法    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread0.start();    thread1.start();    thread2.start();    while (thread0.isAlive() || thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }</code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>运行结果：  </p><pre><code>线程名：Thread-0，普通方法，运行开始  线程名：Thread-1，同步方法，运行开始  线程：Thread-1，同步方法，运行结束,开始调用普通方法  线程名：Thread-1，普通方法，运行开始  线程：Thread-0，普通方法，运行结束  线程：Thread-1，普通方法，运行结束  线程名：Thread-2，同步方法，运行开始  线程：Thread-2，同步方法，运行结束,开始调用普通方法  线程名：Thread-2，普通方法，运行开始  线程：Thread-2，普通方法，运行结束  测试结束</code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>结果分析: &nbsp;<br>我们可以看出，普通方法被两个线程并行执行，不是线程安全的。这是为什么呢？ &nbsp;<br>因为如果非同步方法，有任何其它线程直接调用，而不是仅在调用同步方法，才调用非同步方法，此时会出现多个线程并行执行非同步方法的情况，线程就不安全了。 &nbsp;<br>对于同步方法中调用非同步方法时，要想保证线程安全，就必须保证非同步方法的入口，仅出现在同步方法中。但这种控制方式不够优雅，若被不明情况的人直接调用非同步方法，就会导致原有的线程同步不再安全。所以不推荐大家在项目中这样使用，但我们要理解这种情况，并且我们要用语义明确的、让人一看就知道这是同步方法的方式，来处理线程安全的问题。 &nbsp;<br>所以，最简单的方式，是在非同步方法上，也加上<code>synchronized</code>关键字，使其变成一个同步方法，这样就变成了《场景五：两个线程同时访问同一个对象的不同的同步方法》，这种场景下，大家就很清楚的看到，同一个对象中的两个同步方法，不管那个线程调用，都是线程安全的了。 &nbsp;<br>所以结论是：<br><font color="#7FFFD4">「两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法，仅在没有其他线程直接调用非同步方法的情况下，是线程安全的。若有其他线程直接调用非同步方法，则是线程不安全的。」</font> &nbsp;</p><hr><p><font color="#0000FF">场景六：两个线程同时访问同一个对象的不同的同步方法</font> &nbsp;</p><hr><p>这个场景也是在探讨对象锁的作用范围，对象锁的作用范围是对象中的所有同步方法。所以，当访问同一个对象中的多个同步方法时，结论是:  </p><p><font color="#…FFFD4" size="3">「两个对象同时访问同一个对象的不同的同步方法时，是线程安全的。」</font>  </p><pre><code>public class Condition5 implements Runnable {   static Condition5 instance = new Condition5();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行同步方法method1()     method1();    }   }   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法0，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法0，运行结束");   }   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，同步方法1，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，同步方法1，运行结束");   }   //运行结果:串行   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font>运行结果: &nbsp;<br>是线程安全的。  </p><pre><code>线程名：Thread-1，同步方法1，运行开始  线程：Thread-1，同步方法1，运行结束  线程名：Thread-0，同步方法0，运行开始  线程：Thread-0，同步方法0，运行结束  测试结束  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>结果分析:</strong> &nbsp;<br>两个方法(method0()和method1())的synchronized修饰符，虽没有指定锁对象，但默认所对象为this对象为锁对象，所以对于同一个实例(instance)，两个线程拿到的锁是同一把锁，此时同步方法会串行执行。这也是synchronized关键字的可重入的一种体现。  </p><hr><p><font color="#0000FF">场景七：两个线程分别同时访问静态synchronized和非静态synchronized方法</font>  </p><hr><p>这种场景的本质也是在探讨两个线程获取的是不是同一把锁得问题。静态<font color="#7FFFD4">synchronized</font>方法属于类锁，所对象是<font color="#7FFFD4">(*.class)</font>对象，非静态<font color="#7FFFD4">synchronized</font>方法属于对象锁中的方法锁，所对象是<font color="#7FFFD4">this</font>对象。两个线程拿到的是不同的锁，自然不会相互影响。结论：  </p><p><font color="#7FFFD4" size="3">「两个线程分别同时访问静态synchronized和非静态synchronized方法，线程不安全。」</font> &nbsp;</p><p><font color="#7FFFD4">&lt;/&gt;</font><strong>代码实现:</strong>  </p><pre><code>public class Condition6 implements Runnable {   static Condition6 instance = new Condition6();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行静态同步方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行非静态同步方法method1()     method1();    }   }   // 重点：用static synchronized 修饰的方法，属于类锁，锁对象为（*.class）对象。   private static synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，静态同步方法0，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，静态同步方法0，运行结束");   }   // 重点：synchronized 修饰的方法，属于方法锁，锁对象为（this）对象。   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，非静态同步方法1，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，非静态同步方法1，运行结束");   }   //运行结果:并行   public static void main(String[] args) {    //问题原因： 线程1的锁是类锁（*.class）对象，线程2的锁是方法锁（this）对象,两个线程的锁不一样，自然不会互相影响，所以会并行执行。    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>运行结果:</strong>  </p><pre><code>线程名：Thread-0，静态同步方法0，运行开始  线程名：Thread-1，非静态同步方法1，运行开始  线程：Thread-1，非静态同步方法1，运行结束  线程：Thread-0，静态同步方法0，运行结束  测试结束 </code></pre><hr><p><font color="#0000FF">场景八：同步方法抛出异常后，JVM会自动释放锁的情况</font>  </p><hr><p>本场景讨论的是<font coloe="#7FFFD4">synchronized</font>释放锁的场景：  </p><p><font color="#…FFFD4" size="3">「只有当同步方法执行完或执行时抛出异常这两种情况，才会释放锁。」</font>  </p><p>所以，在一个线程同步方法中出现异常的时候，会释放锁，另一个线程得到锁，继续执行。而不会出现一个线程抛出异常后，另一个线程一直等待获取锁的情况。这是因为JVM在同步方法抛出异常的时候，会自动释放锁对象。<br><font color="#7FFFD4">&lt;/&gt;</font><strong>代码实现：</strong>  </p><pre><code>public class Condition7 implements Runnable {   private static Condition7 instance = new Condition7();   @Override   public void run() {    if (Thread.currentThread().getName().equals("Thread-0")) {     //线程0,执行抛异常方法method0()     method0();    }    if (Thread.currentThread().getName().equals("Thread-1")) {     //线程1,执行正常方法method1()     method1();    }   }   private synchronized void method0() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    //同步方法中，当抛出异常时，JVM会自动释放锁，不需要手动释放，其他线程即可获取到该锁    System.out.println("线程名：" + Thread.currentThread().getName() + "，抛出异常，释放锁");    throw new RuntimeException();   }   private synchronized void method1() {    System.out.println("线程名：" + Thread.currentThread().getName() + "，运行开始");    try {     Thread.sleep(4000);    } catch (InterruptedException e) {     e.printStackTrace();    }    System.out.println("线程：" + Thread.currentThread().getName() + "，运行结束");   }   public static void main(String[] args) {    Thread thread1 = new Thread(instance);    Thread thread2 = new Thread(instance);    thread1.start();    thread2.start();    while (thread1.isAlive() || thread2.isAlive()) {    }    System.out.println("测试结束");   }  }  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>运行结果：</strong>  </p><pre><code>线程名：Thread-0，运行开始  线程名：Thread-0，抛出异常，释放锁  线程名：Thread-1，运行开始  Exception in thread "Thread-0" java.lang.RuntimeException   at com.study.synchronize.conditions.Condition7.method0(Condition7.java:34)   at com.study.synchronize.conditions.Condition7.run(Condition7.java:17)   at java.lang.Thread.run(Thread.java:748)  线程：Thread-1，运行结束  测试结束  </code></pre><p><font color="#7FFFD4">&lt;/&gt;</font><strong>结果分析：</strong> &nbsp;<br>可以看出线程还是串行执行的，说明是线程安全的。而且出现异常后，不会造成死锁现象，JVM会自动释放出现异常线程的所对象，其他线程获取锁继续执行。  </p><hr><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>本文总结了并用代码实现和验证了<font color="#7FFFD4">synchronized</font>各种使用场景，以及各种场景发生的原因和结论。我们分析的理论基础都是<font color="#7FFFD4">synchronized</font>关键字的锁对象究竟是谁？多个线程之间是否竞争同一把锁？根据这个条件来判断线程是否是安全的。所以，有了这些场景的分析锻炼后，我们在以后使用多线程编程时，也可以通过分析锁对象的方式，判断出线程是否是安全的，从而避免此类问题的出现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper</title>
      <link href="2020/05/12/zookeeper/"/>
      <url>2020/05/12/zookeeper/</url>
      
        <content type="html"><![CDATA[<h4 id="ZooKeeper汇总"><a href="#ZooKeeper汇总" class="headerlink" title="ZooKeeper汇总"></a>ZooKeeper汇总</h4><a id="more"></a>  <h5 id="1-ZooKeeper是什么？"><a href="#1-ZooKeeper是什么？" class="headerlink" title="1.ZooKeeper是什么？"></a>1.ZooKeeper是什么？</h5><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个伪分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。  </p><p><strong>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</strong>  </p><p>ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><p>另外，ZooKeeper将数据保存在内存中，性能是非常棒的。在“读”多于“写”的 应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。(“读”多于”写”是协调服务的典型场景)。  </p><h5 id="2-ZooKeeper特点有哪些？"><a href="#2-ZooKeeper特点有哪些？" class="headerlink" title="2. ZooKeeper特点有哪些？"></a>2. ZooKeeper特点有哪些？</h5><ul><li>顺序一致性： 从同一客户端发起的事务请求，最终会严格的按照顺序被应用到ZooKeeper中去。  </li><li>原子性： 所有事物请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事物，要么都没有应用。  </li><li>单一系统映像： 无论客户端连到哪一个ZooKeeper服务器上，其看到的服务端数据模型都是一致的。  </li><li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，知道被下一次更改覆盖。  </li></ul><h5 id="3-ZooKeeper典型应用场景有哪些？"><a href="#3-ZooKeeper典型应用场景有哪些？" class="headerlink" title="3. ZooKeeper典型应用场景有哪些？"></a>3. ZooKeeper典型应用场景有哪些？</h5><p>ZooKeeper概览中，我们介绍到使用其通常被应用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><p>下面选3个典型的应用场景来专门说：<br> 1.<strong>分布式锁：</strong> 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。<br> 2.<strong>命名服务：</strong> 可以通过ZooKeeper的顺序节点生成全局唯一ID。<br> 3.<strong>数据发布/订阅:</strong> 通过<strong>Watcher机制</strong>可以很方便地实现数据发布/订阅。当你将数据发布到ZooKeeper被监听的节点上，其他机器可通过监听ZooKeeper上节点的变化来实现配置的动态更新。  </p><p>实际上，这些功能的实现基本都得益于ZooKeeper可以保存数据的功能，但是ZooKeeper不适合保存大量数据，这一点需要注意。  </p><h6 id="4-有哪些著名的开源项目用到了ZooKeeper？"><a href="#4-有哪些著名的开源项目用到了ZooKeeper？" class="headerlink" title="4. 有哪些著名的开源项目用到了ZooKeeper？"></a>4. 有哪些著名的开源项目用到了ZooKeeper？</h6><p>1.<strong>Kafka:</strong> ZooKeeper主要为Kafka提供Broker和Topic的注册以及多个Partition的负载均衡等功能。<br>2.<strong>Hbase：</strong> ZooKeeper为Hbase提供确保整个集群只有一个Master以及保存和提供regionserver状态信息(是否在线)等功能。<br>3.<strong>Hadoop:</strong> ZooKeeper为Namenode提供高可用支持。  </p><h5 id="5-ZooKeeper-Data-model（数据模型）？"><a href="#5-ZooKeeper-Data-model（数据模型）？" class="headerlink" title="5. ZooKeeper Data model（数据模型）？"></a>5. ZooKeeper Data model（数据模型）？</h5><p>ZooKeeper数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二进制序列。并且，每个节点还可以拥有N个子节点，最上层是根节点以“/”来代表。每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最小单元。并且，每个znode都是一个唯一的路径标识。  </p><p>强调一句：<strong>ZooKeeper主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在znode上，ZooKeeper给出的上限是每个节点的数据大小最大是1M。</strong>  </p><p>从下图可以更直观地看出：ZooKeeper节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用斜杠”/“进行分割的路径表示，开发人员可以向这个节点汇总写入数据，也可以在节点下面创建子节点。<br><img src="/img/zk01.png">  </p><h5 id="6-ZooKeeper-znode-4种类型是什么？"><a href="#6-ZooKeeper-znode-4种类型是什么？" class="headerlink" title="6. ZooKeeper znode 4种类型是什么？"></a>6. ZooKeeper znode 4种类型是什么？</h5><p>我们通常是将znode分为4大类：  </p><ul><li><strong>持久（PERSISTENT）节点：</strong> 一旦创建就一直存在即使ZooKeeper集群宕机，直到将其删除。  </li><li><strong>临时（EPHEMERAL）节点：</strong> 临时节点的生命周期是与<strong>客户端会话(session)**绑定的，</strong>会话消失则节点消失<strong>。并且，</strong>临时节点只能做叶子节点**，不能创建子节点。  </li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点：</strong>  除了具有持久（PERSISTENT）节点的特性之外，子节点的名称还具有顺序性。比如’/node1/app0000000001’、’/node1/app0000000002’。  </li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点:</strong> 除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。  </li></ul><h6 id="7-ZooKeeper-znode数据结构？"><a href="#7-ZooKeeper-znode数据结构？" class="headerlink" title="7. ZooKeeper znode数据结构？"></a>7. ZooKeeper znode数据结构？</h6><p>每个znode由2部分组成：  </p><ul><li><strong>stat:</strong> 状态信息</li><li><strong>data:</strong> 节点存放的数据的具体内容<br>如下所示，我通过get命令来获取根目录下的dubbo节点的内容。  <pre><code>[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo# 该数据节点关联的数据内容为空null# 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出cZxid = 0x2ctime = Tue Nov 27 11:05:34 CST 2018mZxid = 0x2mtime = Tue Nov 27 11:05:34 CST 2018pZxid = 0x3cversion = 1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 1Copy to clipboardErrorCopied</code></pre>Stat类中包含了一个数据节点的所有状态信息的字段，包括十五ID-cZxid、节点创建时间-ctime和子节点个数-numChildren等等。  </li></ul><p>下面我们来看一下每个znode状态系信息酒精代表的是什么吧！(下面的内容来源于《从Paxos到ZooKeeper分布式一致性原理与实践》):  </p><table><thead><tr><th>znode状态信息</th><th>解释</th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID,即该数据节点被创建时的事务id</td></tr><tr><td>ctime</td><td>create time，即该节点的创建时间</td></tr><tr><td>mZXID</td><td>modified ZXID，即该节点最终一次更新时的事务id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加 1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td></tr><tr><td>aclVersion</td><td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><h5 id="8-ZooKeeper-Watcher-事件监听器-？"><a href="#8-ZooKeeper-Watcher-事件监听器-？" class="headerlink" title="8. ZooKeeper Watcher(事件监听器) ？"></a>8. ZooKeeper Watcher(事件监听器) ？</h5><p>Watcher（事件监听器），是ZooKeeper中的一个很重要的特性。ZooKeeper允许用户在指点节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。<br><img src="/img/zk02.png"><br>Watcher机制官方声明：一个Watcher事件是一个一次性的触发器，当被设置了Watcher的数据发生了改变的时候，则服务器将这个改变发送给设置了Watcher的客户端，以便通知它们。  </p><p>ZooKeeper Watcher机制的特点：</p><ol><li>一次性触发数据发生改变时，一个watcher event会被发送到client，但是client只会收到一次这样的信息。  </li><li>watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于ZooKeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用ZooKeeper不能期望能够监控到节点的每次变化。ZooKeeper只能保证最终的一致性，而无法保证强一致性。  </li><li>数据监视ZooKeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。  </li><li>注册watcher getData、exists、 getChildren  </li><li>触发watcher create、delete、 setData  </li><li>setData()会触发znode上设置的data watch(如果set成功的话)。一个成功的create()操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的delete()操作将会同时触发一个znode的data watch 和child watch(因为这样就没有子节点了)，同时也会触发其父节点的child watch。  </li><li>当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前有删除了，这种情况下，这个watch事件可能会被丢失。  </li><li>Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watch的布尔类型。  </li></ol><h5 id="9-ZooKeeper集群？"><a href="#9-ZooKeeper集群？" class="headerlink" title="9. ZooKeeper集群？"></a>9. ZooKeeper集群？</h5><p>为了保证高可用，最好是以集群形态来部署ZooKeeper，这样只要集群中大部分机器是可用的(能够容忍一定的机器故障)，那么ZooKeeper本身仍然是可用的。通常3台服务器就可以构成一个ZooKeeper集群了。ZooKeeper官方提供的架构图就是一个ZooKeeper集群整体对外提供服务。<br><img src="/img/zk03.png"><br>上图中每一个server代表一个安装ZooKeeper服务的服务器。组成ZooKeeper服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间否互相保持着通信。集群间通过ZAB协议(ZooKeeper Atomic Broadcast)来保持数据的一致性。  </p><p>**最典型集群模式：Master/Slave模式(主备模式)**。在这种模式中，通常Master服务器作为主服务器提供写服务，其他的Slave服务器从服务器通过异步复制的方式获取Master服务器最新的数据提供读服务。  </p><h5 id="10-ZooKeeper集群角色？"><a href="#10-ZooKeeper集群角色？" class="headerlink" title="10. ZooKeeper集群角色？"></a>10. ZooKeeper集群角色？</h5><p>但是，在ZooKeeper中没有选择传统的Master/Slave概念，而是引入了Leader、Follower和Observer三种角色。如下图所示：<br><img src="/img/zk04.png"><br>ZooKeeper集群中的所有机器通过一个<strong>Leader选举过程</strong>来选定一台成为“<strong>Leader</strong>”的机器，Leader既可以为客户端提供写服务又能提供读服务。除了Leader以外，<strong>Follower</strong>和“<strong>Observer</strong>”都只能提供读服务。Follower和Observer唯一的区别在于Observer机器不参与Leader的选举过程，也不参与写操作的”过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。  </p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Leader</td><td>微客户端提供读和写的服务，负责投票的发起和决议，更新系统状态</td></tr><tr><td>Follower</td><td>为客户端提供读服务，如果是写服务则转发给Leader。在选举过程中参与投票</td></tr><tr><td>Observer</td><td>为客户端提供读服务，如果是写服务则转发给Leader。不参与选举过程中的投票。也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于ZooKeeper3.3系列新增的角色。</td></tr></tbody></table><p>当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入Leader选举过程，这个过程会选举产生新的Leader的服务器。<br>这个过程大致是这样的：  </p><ol><li><strong>Leader election（选举阶段）</strong>: 节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准Leader。  </li><li><strong>Discovery（发现阶段）</strong>： 在这个阶段，followers跟准Leader进行通信，同步followers最近接受的事务提议。  </li><li><strong>Synchronization（同步阶段）</strong>： 同步阶段主要是利用leader前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准leader才会成为真正的leader。  </li><li><strong>Broadcast（广播阶段）</strong>: 到了这个阶段，ZooKeeper集群才能正式对外提供事务服务，并且leader可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。  </li></ol><h5 id="11-ZooKeeper集群为啥最好是奇数台？"><a href="#11-ZooKeeper集群为啥最好是奇数台？" class="headerlink" title="11.ZooKeeper集群为啥最好是奇数台？"></a>11.ZooKeeper集群为啥最好是奇数台？</h5><p>ZooKeeper集群在宕掉几个ZooKeeper服务器之后，如果剩下的ZooKeeper服务器个数大于宕掉的个数的话整个ZooKeeper才依然可用。加入我们的集群中有N台ZooKeeper服务器，那么也就是剩下的服务数必须大于N/2.先说一下结论，2N和2N-1的容忍度是一样的，都是N-1大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。比如假如我们有3台，那么最大允许宕掉1台ZooKeeper服务器，如果我们有4台的时候也同样只允许宕掉一台。加入我们有5台，那么我们最大允许宕掉2台ZooKeeper服务器，如果我们有6台的时候同样只允许宕掉2台。  </p><p>综上，何必增加那一个不必要的ZooKeeper呢？  </p><h5 id="12-ZooKeeper如何选举master节点？"><a href="#12-ZooKeeper如何选举master节点？" class="headerlink" title="12. ZooKeeper如何选举master节点？"></a>12. ZooKeeper如何选举master节点？</h5><p>还记得上面我们所说的临时节点么？ 因为’ZooKeeper’的强一致性，能够很好地在保证<strong>在高并发的情况下保证节点创建的全局唯一性</strong>(即无法重复创建同样的节点)。  </p><p>利用这个特性，我们可以<strong>让多个客户端创建一个指定的节点</strong>，创建成功的就是<code>master</code>。<br>但是如果这个<code>master</code>挂了怎么办？？？<br>想想我们为什么要创建临时节点？还记得临时节点的生命周期么？<code>master</code>挂了是不是代表会话断了？会话断了是不是意味着这个节点就没有了？还记得<code>watcher</code>吗？我们是不是可以<strong>让其他不是<code>master</code>的节点监听节点的状态</strong>，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表<code>master</code>挂了，这个时候我们<strong>触发回调函数进行重新选举</strong>，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断<code>master</code>是否挂了等等。<br><img src="/img/zk05.jpg"><br>总的来说，我们可以完全<strong>利用临时节点、节点状态和watcher来实现选主的功能</strong>，临时节点主要用来选举，节点状态和<code>watcher</code>可以用来判断<code>master</code>的活性和进行重新选举。  </p><h5 id="13-ZooKeeper如何实现分布式锁？"><a href="#13-ZooKeeper如何实现分布式锁？" class="headerlink" title="13. ZooKeeper如何实现分布式锁？"></a>13. ZooKeeper如何实现分布式锁？</h5><p>分布式多的实现方式油和多种，比如<code>Redis</code>、数据库、<code>ZooKeeper</code>等。个人认为<code>ZooKeeper</code>在实现分布式锁这方面是非常非常简单的。  </p><p>上面我们已经提过了<strong>zk在高并发的情况下保证节点创建的全局唯一性</strong>，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式情况下，所以能实现分布式锁。  </p><p>如何实现呢？其实跟选主基本一样，我们也可以利用临时节点的创建来实现。  </p><p>首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong>。然后没有获取到锁的客户端也像上面选主的非主节点创建一个<code>watcher</code>进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。  </p><blockquote><p><code>zk</code>中不需要像<code>Redis</code>那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。  </p></blockquote><p>那能不能<code>zookeeper</code>同时实现共享锁和独占锁呢？答案是可以的，不过稍微有点复杂。  </p><p>还记得有序节点么？  </p><p>这个时候规定所有创建节点必须有序，当你是读请求(要获取共享锁)的话，如果<strong>如果没有比自己更小的节点，或比自己小的节点都是读请求</strong>，则可以获取到读锁，然后就可开始读了。<strong>若比自己小的节点中有请求</strong>，则当前客户端无法获取到读锁，只能等待前面的写请求完成。  </p><p>如果你是写请求(获取独占锁)，若<strong>没有比自己更小的节点</strong>，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现<strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong>，等待所有前面的操作完成。  </p><p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如一个锁得到释放它会通知所有等待的客户端从而造成<strong>羊群效应</strong>。此时你可以通过让等待的节点只监听他们前面的节点。  </p><p>具体怎么做呢？其实也很简单，你可以让<strong>读请求监听比自己小的最后一个写请求节点，写请求只监听比自己晓得最后一个节点</strong>。  </p><h5 id="14-ZooKeeper架构？"><a href="#14-ZooKeeper架构？" class="headerlink" title="14. ZooKeeper架构？"></a>14. ZooKeeper架构？</h5><p>作为一个优秀高效且可靠的分布式协调框架，<code>zookeeper</code>在解决分布式数据一致性问题时并没有直接使用<code>Paxos</code>，而是专门定制了一致性协议叫做<code>ZAB(ZooKeeper Automic Broadcast)</code>原子广播协议，该协议能够很好地支持<code>崩溃恢复</code>。<br><img src="/img/zk03.png">  </p><h5 id="15-ZooKeeper特点总结？"><a href="#15-ZooKeeper特点总结？" class="headerlink" title="15. ZooKeeper特点总结？"></a>15. ZooKeeper特点总结？</h5><ol><li>ZooKeeper本身就是一个分布式程序(只要半数以上节点存活，ZooKeeper就能正常服务)。  </li><li>为了保证高可用，最好是以集群形态来部署ZooKeeper，这样只要集群中大部分机器是可用的(能够容忍一定的机器故障)，那么ZooKeeper本身仍然是可用的。  </li><li>ZooKeeper将数据保存在内存中，这也就保证了高吞吐量和低延迟(但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因)。  </li><li>ZooKeeper是高性能的。在”读“多于”写“的应用程序中尤其的明显，因为”写“会导致所有的服务器间同步状态。(”读“多于”写“是协调服务的典型场景)。  </li><li>ZooKeeper有临时节点的概念。当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点就被删除。持久节点是指一旦这个znode被创建了，除非主动进行znode的移除操作，否则这个znode将一直保存在ZooKeeper上。  </li><li>ZooKeeper底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2019/12/01/spring01/"/>
      <url>2019/12/01/spring01/</url>
      
        <content type="html"><![CDATA[<h5 id="Spring-SpringMVC-SpringBoot-SpringCloud有什么区别和关联？"><a href="#Spring-SpringMVC-SpringBoot-SpringCloud有什么区别和关联？" class="headerlink" title="Spring, SpringMVC, SpringBoot, SpringCloud有什么区别和关联？"></a>Spring, SpringMVC, SpringBoot, SpringCloud有什么区别和关联？</h5><a id="more"></a><p><font color="#006400" size="4px">简单介绍</font>  </p><p>Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架。Spring使你能够编写干净、更可管理、并且更易于测试的代码。  </p><p>SpringMVC是Spring的一个模块，一个web框架。通过Dispatcher Servlet，ModelAndView和View Resolver，开发web应用变得很容易，主要针对的是网站应用程序或者服务开发–URL路由、Session、模板引擎、静态web资源等等。  </p><p>Spring配置繁琐，复杂，所以推出了SpringBoot，约定优于配置，简化了spring的配置流程。  </p><p>SpringCloud构建于SpringBoot之上，是一个关注全局的服务治理框架。  </p><p><strong>Spring VS SpringMVC</strong>  </p><p>Spring是一个一站式的轻量级的java开发框架，核心是控制反转(IOC)和面向切面(AOP)，针对开发的WEB层(SpringMVC)、业务层(IOC)、持久层(jdbcTemplate)等都提供了多种配置解决方案；  </p><p>SpringMVC是Spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于Spring框架中WEB层开发的一部分；  </p><p><strong>SpringMVC VS SpringBoot</strong>  </p><p>SpringMVC属于一个企业web开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对于比较繁琐复杂；  </p><p>SpringBoot框架相对于SpringMVC框架来说，更专注于开发微服务后台接口，不开发前端视图；  </p><p><strong>SpringBoot VS SpringCloud</strong>  </p><p>SpringBoot使用了约定大于配置的理念，集成了快速开发的Spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；  </p><p>SpringCloud大部分的功能插件都是基于SpringBoot单体微服务进行整合以及管理；SpringCloud依赖于SpringBoot开发，而SpringBoot可以独立开发； </p><p><font color="#006400" size="4px">总结下来</font>  </p><ul><li>Spring是核心，提供了基础功能；  </li><li>SpringMVC是基于Spring的一个MVC框架；  </li><li>SpringBoot是为简化Spring配置的快速开发整合包；  </li><li>SpringCloud是构建在SpringBoot之上的服务治理框架。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="2019/11/25/hashmap/"/>
      <url>2019/11/25/hashmap/</url>
      
        <content type="html"><![CDATA[<h4 id="HashMap底层实现原理以及JDK8的优化"><a href="#HashMap底层实现原理以及JDK8的优化" class="headerlink" title="HashMap底层实现原理以及JDK8的优化"></a>HashMap底层实现原理以及JDK8的优化</h4><a id="more"></a>  <p>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8并且容量大于64时，链表结构会转换成红黑树结构，它的组成结构如下图所示： &nbsp;<br><img src="/img/hashmap01.png"> &nbsp;<br>数组中的元素我们称之为哈希桶，它的定义如下：  </p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中next表示链表的下一个节点。<br>JDK1.8之所以添加红黑树是因为一旦链表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查的特点，这样就可以有效地解决链表过长时操作比较慢的问题。  </p><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><ul><li>JDK1.8HashMap扩容时做了哪些优化？  </li><li>加载因子为什么是0.75？  </li><li>当有哈希冲突时，HashMap是如何查找并确认元素的？  </li><li>HashMap源码中有哪些重要的方法？  </li><li>HashMap是如何导致死循环的？  </li></ul><hr><ol><li><strong>HashMap源码分析</strong>  <blockquote><p>本文章在未作说明的的情况下，都是以1.8为例来进行源码分析的  </p></blockquote></li></ol><p>HashMap源码中包含了以下几个属性：  </p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//hashMap初始化长度</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">//HashMap最大长度</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1073741824</span><span class="token comment" spellcheck="true">// 默认的加载因子（扩容因子）</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75F</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当链表长度大于此值时，且容量大于64时</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最小树容量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span></code></pre><p><strong>什么是加载因子？加载因子为什么是0.75</strong><br>加载因子也叫扩容因子或者负载因子，用来判断什么时候进行扩容，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。<br>那加载因子为什么是0.75而不是0.5或者1.0呢？<br>这其实是出于容量和性能之间平衡的结果：  </p><ul><li>当加载因子设置值比较大的时候，扩容的门槛就提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生hash冲突的几率就会提高，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；  </li><li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生hash冲突的可能性就比较小，因此操作性能会比较高。  </li></ul><p>所以综合了以上情况就取了一个0.5到1.0的平均值0.75作为加载因子。<br>HashMap中三个最重要的方法：查询、新增和数据扩容。<br>先来看查询源码：  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对key进行hash操作</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//非空判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 判断第一个元素是否是要查询的元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> first<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一个节点的非空判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如过第一个节点是树结构，则使用getTreeNode直接获取相应的数据</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 非树结构，循环判断节点</span>                      <span class="token comment" spellcheck="true">//hash相等并且key相同，返回此节点</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从以上源码可以看出，当哈希冲突时我们需要判断key值是否相等，才能确认此元素是不是我们想要的元素。<br>HashMap第二个重要的的方法：<strong>新增方法</strong>，源码如下：  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对key进行hash操作</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 哈希表为空则创建表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 根据key的哈希值计算出要插入的数组索引 i</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 如果table[i]等于null，则直接插入</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果key已经存在了，直接覆盖key</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果key不存在，判断是否为红黑树</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//红黑树直接插入键值对</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 为链表结构，循环准备插入</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 下一个元素为空时</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 转换为红黑树进行处理</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// key已经存在直接覆盖value</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 超过最大容量，扩容</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>新增方法的执行流程，如下图所示：<br><img src="/img/hashmap_put.png">  </p><p>HashMap第三个重要的方法是扩容方法，源码如下：  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//扩容前的数组</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//扩容前的数组的大小和阈值</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预定义新数组的大小和阈值</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 超过最大值就不在扩容了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 扩大容量为当前容量的两倍，但不能超过MAXIMUN_CAPACITY</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当前数组没有数据，使用初始化的值</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>            <span class="token comment" spellcheck="true">// 如果初始化的值为0，则使用默认的初始化容量</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果新的容量等于0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 开始扩容，将新的容量赋值给table</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 原数据不为空，将原数据复制到新的table中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 如果链表只有一个，将进行直接赋值</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">// 红黑相关的操作</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                        <span class="token comment" spellcheck="true">//链表复制，JDK1.8扩容优化部分</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token punctuation">{</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//元索引</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">// 原索引 + oldCap</span>                            <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//将原索引方法hash桶中</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//将原索引 + oldCap放到hash桶中</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算(e.hash &amp; oldCap)来确定元素是否需要移动，比如key1的信息如下：  </p><ul><li>key1.hash = 1 0000 1010  </li><li>oldCap = 16 0001 0000<br>使用e.hash &amp; oldCap得到的结果，高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key2信息如下：  </li><li>key2.hash = 10 0001 0001  </li><li>oldCap = 16 0001 0000<br>这时候的得到的结果，高一位为1，当结果为1时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置+原数组长度，如下图所示：<br><img src="/img/hashmap02.png"><br>其中红色的虚线图代表了扩容时元素移动的位置。  </li></ul><ol start="2"><li><strong>HashMap死循环分析</strong><br>以JDK1.7为例，假设HashMap的默认大小为2，原本HashMap中有一个元素key(5),我们再使用两个线程：t1添加元素key(3),t2添加元素key(7),当元素key(3)跟key(7)两个元素都添加到HashMap之后，线程t1在执行到Entry&lt;K,V&gt; next = e.next;时，交出了CPU的使用权源码如下：  </li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 线程一执行此处</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                        e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                        e <span class="token operator">=</span> next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>那么此时线程t1中的e指向了key(3)，而next指向了key(7);之后线程t2重新rehash之后链表的顺序被反转，链表的位置变成了key(5)-&gt;key(7)-&gt;key(3),其中“-&gt;”用来表示下一个元素。<br>当t1重新获得执行权之后，先执行newTable[i] = e把key(3)的next值设置为key(7),而下次循环时查询到key(7)的next元素为key(3),于是就形成了key(3)和key(7)的循环引用，因此就导致了死循环的发生，如下图所示：<br><img src="/img/hashmap03.png">  </p><p>当然发生死循环的原因是JDK1.7链表插入方式为首部倒序插入，这个问题在1.8得到了改善，变成了尾部正序插入。  </p><p>因为hashmap本身就是非线程安全的，如果要在多线程下，SUN公司建议使用ConcurrentHashMap替代。  </p><p><strong>小结</strong>  </p><p>在 JDK 1.7 时 HashMap 是由数组和链表组成的，而 JDK 1.8 则新增了红黑树结构，当链表长度达到 8 并且容器达到 64 时会转换为红黑树存储，以提升元素的操作性能。同时还介绍了 HashMap 的三个重要方法，查询、添加和扩容，以及 JDK 1.7 resize()  在并发环境下导致死循环的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么16个数据库</title>
      <link href="2019/11/25/redis01/"/>
      <url>2019/11/25/redis01/</url>
      
        <content type="html"><![CDATA[<h4 id="Redis为什么默认16个数据库？"><a href="#Redis为什么默认16个数据库？" class="headerlink" title="Redis为什么默认16个数据库？"></a>Redis为什么默认16个数据库？</h4><a id="more"></a><ul><li>一、 16个数据库的由来  </li><li>二、 正确理解Redis的“数据库”概念  </li><li>三、 集群情况下是否支持一个实例多个db？  </li><li>四、 总结  </li></ul><p>导读：在实际项目中Redis常被用于做缓存，分布式锁、消息队列等。但是在搭建配置好Redis服务器后很多人应该会发现和有这样的一问，为什么Redis默认建立了16个数据库，如下图所示。<br><img src="/img/redis01.jpg">  </p><h2 id="一、-16个数据库的由来"><a href="#一、-16个数据库的由来" class="headerlink" title="一、 16个数据库的由来"></a>一、 16个数据库的由来</h2><p>Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与在一个关系数据库实例中可以创建多个数据库类似(如下图所示)，所以可以将其中的每个字典都理解成一个独立的数据库。<br><img src="/img/redis02.jpg"><br>  以MySQL实例为例 </p><p>Redis默认支持16个数据库，可以通过调整Redis的配置文件redis/redis.conf中的database来修改这一个值，设置完毕后重启Redis便完成配置。<br><img src="/img/redis03.jpg"><br>客户端与Redis建立连接后会默认选择0号数据库，不过可以随时使用SELECT命令更换数据库。<br><img src="/img/redis04.png"><br>在实际项目中则可以通过Redis配置文件的形式指定数据库，如下图所示<br><img src="/img/redis05.jpg">  </p><h2 id="二、-正确理解Redis的“数据库”概念"><a href="#二、-正确理解Redis的“数据库”概念" class="headerlink" title="二、 正确理解Redis的“数据库”概念"></a>二、 正确理解Redis的“数据库”概念</h2><p>由于Redis不支持自定义数据库的名字，所以每个数据库都以编号命名。开发者则需要自己记录存储的数据与数据库的对应关系。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么全部数据库都没有权限访问。但是，要正确地理解Redis的“数据库”概念这里不得不提到一个命令：</p><p><img src="/img/redis06.jpg">  </p><p>该命令可以清空实例下的所有的数据库数据，这与我们所熟知的关系型数据库所不同。关系型数据库多个库常用于存储不同应用程序的数据，且没有方式可以同时清空实例下的所有数据库。所以对于Redis来说这些db更像是一种命名空间，且不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库存储B应用的数据，不同的应用应该使用不同的Redis实例存储数据。Redis非常轻量级，一个空Redis实例占用的内存只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。  </p><h2 id="三、-集群情况下是否支持一个实例多个db？"><a href="#三、-集群情况下是否支持一个实例多个db？" class="headerlink" title="三、 集群情况下是否支持一个实例多个db？"></a>三、 集群情况下是否支持一个实例多个db？</h2><p><img src="/img/redis07.jpg"><br>要注意以上所说的都是基于单体Redis的情况。而在集群的情况下不支持使用select命令来切换db，因为Redis集群模式下只有一个db0.在扩展一些集群与单机Redis的区别。  </p><ul><li>key批量操作支持有限：例如mget、mset必须在一个slot  </li><li>key事务和Lua支持有限：操作的key必须在一个节点  </li><li>key是数据enquiry的最小粒度：不支持bigkey分区  </li><li>不支持多个数据库：集群模式下只有一个db0  </li><li>复制只支持一层：不支持树形复制结构  </li></ul><h2 id="四、-总结"><a href="#四、-总结" class="headerlink" title="四、 总结"></a>四、 总结</h2><p>Redis实例默认建立了16个db，由于不支持自主进行数据库命名所以以dbx的当时命名。默认数据库数量可以修改配置文件的database值来设定。对于db正确的理解应该为“命名空间”，多个应用程序不应使用同一个Redis不同库，而应一个应用程序对应一个Redis实例，不同的数据库可用于存储不同环境的数据。最后要注意，Redis集群下只有db0，不支持多db。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String</title>
      <link href="2018/11/24/string/"/>
      <url>2018/11/24/string/</url>
      
        <content type="html"><![CDATA[<h4 id="String的特点是什么？它有哪些重要方法？"><a href="#String的特点是什么？它有哪些重要方法？" class="headerlink" title="String的特点是什么？它有哪些重要方法？ &nbsp;"></a>String的特点是什么？它有哪些重要方法？ &nbsp;</h4><a id="more"></a>  <h6 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h6><p>以主流的的JDK8来说，String内部实际存储结构为char的数组，源码如下:</p><pre><code>public final&nbsp;class&nbsp;String   implements&nbsp;java.io.Serializable,&nbsp;Comparable&lt;String&gt;,&nbsp;CharSequence&nbsp;{//&nbsp;用于存储字符串的值&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;char&nbsp;value[];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;缓存字符串的&nbsp;hash&nbsp;code&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;hash;&nbsp;//&nbsp;Default&nbsp;to&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;......其他内容}</code></pre><p>String源码中包含下面几个重要的方法</p><h6 id="1-多构造方法"><a href="#1-多构造方法" class="headerlink" title="1.  多构造方法"></a>1.  多构造方法</h6><p>String字符串有以下4个重要的构造方法:</p><pre><code>//&nbsp;String&nbsp;为参数的构造方法public&nbsp;String(String&nbsp;original)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;original.value;&nbsp;&nbsp;&nbsp;&nbsp;this.hash&nbsp;=&nbsp;original.hash;}//&nbsp;char[]&nbsp;为参数构造方法public&nbsp;String(char&nbsp;value[])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(value,&nbsp;value.length);}//&nbsp;StringBuffer&nbsp;为参数的构造方法public&nbsp;String(StringBuffer&nbsp;buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;synchronized(buffer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(buffer.getValue(),&nbsp;buffer.length());&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;StringBuilder&nbsp;为参数的构造方法public&nbsp;String(StringBuilder&nbsp;builder)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;this.value&nbsp;=&nbsp;Arrays.copyOf(builder.getValue(),&nbsp;builder.length());}</code></pre><p>其中，比较容易被我们忽略的是以StringBuffer和StringBuilder为参数的构造函数，因为这三中数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p><h6 id="2-equals-比较两个字符串是否相等"><a href="#2-equals-比较两个字符串是否相等" class="headerlink" title="2. &nbsp;equals()比较两个字符串是否相等"></a>2. &nbsp;equals()比较两个字符串是否相等</h6><p>源码如下:</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><p>String类型重写了Object中的equals()方法，equals()方法需要传递一个Object类型的参数值，在比较时会先通过instanceof判断是否为String类型，如果不是则会直接返回false，instanceof的使用如下</p><pre><code>Object&nbsp;oString&nbsp;=&nbsp;"123";Object&nbsp;oInt&nbsp;=&nbsp;123;System.out.println(oString&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;trueSystem.out.println(oInt&nbsp;instanceof&nbsp;String);&nbsp;//&nbsp;返回&nbsp;false</code></pre><p>当判断参数为String类型后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回true，否则则返回false。<br>还有一个和equals()比较类似的方法equalslgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p><h6 id="3-compareTo-比较两个字符串"><a href="#3-compareTo-比较两个字符串" class="headerlink" title="3. &nbsp;compareTo()比较两个字符串"></a>3. &nbsp;compareTo()比较两个字符串</h6><p>compareTo()方法用于比较两个字符串，返回的结果为int类型的值，源码如下:</p><pre><code>public&nbsp;int&nbsp;compareTo(String&nbsp;anotherString)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len1&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len2&nbsp;=&nbsp;anotherString.value.length;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取到两个字符串长度最短的那个&nbsp;int&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;lim&nbsp;=&nbsp;Math.min(len1,&nbsp;len2);&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对比每一个字符&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(k&nbsp;&lt;&nbsp;lim)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c1&nbsp;=&nbsp;v1[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c2&nbsp;=&nbsp;v2[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c1&nbsp;!=&nbsp;c2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;有字符不相等就返回差值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c1&nbsp;-&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;len1&nbsp;-&nbsp;len2;}</code></pre><p>从源码可以看出，comapareTo()方法会循环对比所有的字符串，当两个字符串中有人以一个字符不相同时，则return char1 - char2,。比如，两个字符串分别存储的是1和2，返回的值是-1；如果存储的是1，返回的值是0，如果存储的是2和1，返回的值是1。 &nbsp;<br>还有一个和compareTo()比较类似的方法compareToLgnoreCase()，用于忽略大小写后比较两个字符串。 &nbsp;<br>可以看出compareTo()方法和equals()方法都适用于比较两个字符串的，但他们有两点不同:</p><ul><li><font color="#0000FF">equals()可以接收一个Object类型的参数，而compareTo()只能接收一个String类型的参数</font> &nbsp;</li><li><font color="#0000FF">equals()返回值为Boolean，而compareTo()的返回值则为int。</font> &nbsp;<br>它们都可以用于两个字符串的比较，当equals()方法返回true时，或者是compareTo()方法返回0时，则表示两个字符串完全相同。  </li></ul><h6 id="4-其他重要方法"><a href="#4-其他重要方法" class="headerlink" title="4. &nbsp;其他重要方法"></a>4. &nbsp;其他重要方法</h6><ul><li><font color="#0000FF">indexOf():查询字符串首次出现的下标位置</font> </li><li><font color="#0000FF">lastIndexOf():查询字符串最后出现的下标位置</font></li><li><font color="#0000FF">contains():查询字符串中是否包含另一个字符串</font> </li><li><font color="#0000FF">toLowerCase():把字符串全部转换成小写</font></li><li><font color="#0000FF">toUpperCase():把字符串全部转换成大写</font></li><li><font color="#0000FF">length():查询字符串的长度</font></li><li><font color="#0000FF">trim():去掉字符串的首尾空格</font></li><li><font color="#0000FF">replace():替换字符串中的某些字符</font></li><li><font color="#0000FF">split():把字符串分割并返回字符串数组</font></li><li><font color="#0000FF">join():把字符串数组转换为字符串</font></li></ul><h6 id="5-和equals-的区别"><a href="#5-和equals-的区别" class="headerlink" title="5. &nbsp;==和equals()的区别"></a>5. &nbsp;==和equals()的区别</h6><p>==对于基本数据类型来说，适用于比较”值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。<br>查看源码我们可以知道Object中也有equals()方法，源码如下: &nbsp; </p><pre><code>public boolean equals(Object obj){    return (this == obj);}</code></pre><p>可以看出，Object中的equals()方法其实就是==，而String重写了equals()方法把它修改成比较两个字符串的值是否相等。 &nbsp;<br>源码如下：</p><pre><code>public&nbsp;boolean&nbsp;equals(Object&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;对象引用相同直接返回&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(this&nbsp;==&nbsp;anObject)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判断需要对比的值是否为&nbsp;String&nbsp;类型，如果不是则直接返回&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(anObject&nbsp;instanceof&nbsp;String)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;anotherString&nbsp;=&nbsp;(String)anObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;value.length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;anotherString.value.length)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把两个字符串都转换为&nbsp;char&nbsp;数组对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v1[]&nbsp;=&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;v2[]&nbsp;=&nbsp;anotherString.value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;循环比对两个字符串的每一个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n--&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果其中有一个字符不相等就&nbsp;true&nbsp;false，否则继续对比&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v1[i]&nbsp;!=&nbsp;v2[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;}</code></pre><h6 id="6-final修饰的好处"><a href="#6-final修饰的好处" class="headerlink" title="6.  final修饰的好处"></a>6.  final修饰的好处</h6><p>从String类的源码我们可以看出String是被final修饰的不可继承类。<br>那这样设计有什么好处呢？<br>使用final修饰能够缓存结果，当你在传参时不需要考虑谁会修改他的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。 &nbsp;<br>另外一个原因就是因为<strong>安全</strong>，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，他的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使String类设计成不可变类的一个重要原因。 &nbsp;<br>总结来说，使用final修饰的第一个好处是__安全__；第二个好处是__高效__，以JVM中的字符串常量池举例，如下两个变量:</p><pre><code>String s1 = "java";String s2 = "java";</code></pre><p>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示:  </p><p><img src="/img/finalStr.png"></p><p>试想一下如果String是可变的，那当s1的值修改之后，s2的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h6 id="7-String和StringBuffer、StringBuilder的区别"><a href="#7-String和StringBuffer、StringBuilder的区别" class="headerlink" title="7.  String和StringBuffer、StringBuilder的区别"></a>7.  String和StringBuffer、StringBuilder的区别</h6><p>因为String类型是不可变的，所以在字符串拼接的时候如果我们使用的String的话性能会很低，因此我们就需要使用另一个数据类型StringBuffer，他提供了append和insert方法可以用于字符串的拼接，它使用synchronized来保证线程安全，如下源码所示:</p><pre><code>@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(Object&nbsp;obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(String.valueOf(obj)); &nbsp;&nbsp;&nbsp;return&nbsp;this;}@Overridepublic&nbsp;synchronized&nbsp;StringBuffer&nbsp;append(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;toStringCache&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;super.append(str);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;}</code></pre><p>因为它使用了synchronized来保证线程安全，所以性能不是很高，于是在JDK1.5就有了StringBuilder，它同样提供了append和insert的拼接方法，但他没有使用synchronized来修饰，因此在性能上要优于StringBuffer，所以在非并发环境下可以使用StringBuilder来进行字符串拼接。</p><h6 id="8-String和JVM"><a href="#8-String和JVM" class="headerlink" title="8.  String和JVM"></a>8.  String和JVM</h6><p>String常见的创建方式有两种，new String()的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而new String()的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示:  </p><pre><code>String&nbsp;s1&nbsp;=&nbsp;new&nbsp;String("Java");String&nbsp;s2&nbsp;=&nbsp;s1.intern();String&nbsp;s3&nbsp;=&nbsp;"Java";System.out.println(s1&nbsp;==&nbsp;s2);&nbsp;//&nbsp;falseSystem.out.println(s2&nbsp;==&nbsp;s3);&nbsp;//&nbsp;true</code></pre><p>它们在JVM存储的位置，如下图所示：<br><img src="/img/jvmStr.png">  </p><blockquote><p>JDK1.7之后把永生代换成了元空间，把字符串常量池从方法区移到了Java堆上</p></blockquote><p>除此之外编译器还会对String字符串做一些优化，例如以下代码:</p><pre><code>String s1 = "ja" + "va";String s2 = "java";System.out.println(s1 == s2);</code></pre><p>虽然s1拼接了多个字符串，但对比的结果确实true，我们使用反编译工具，看到的结果如下：</p><pre><code>Compiled&nbsp;from&nbsp;"StringExample.java"public&nbsp;class&nbsp;com.lagou.interview.StringExample&nbsp;{&nbsp;&nbsp;public&nbsp;com.lagou.interview.StringExample();&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;invokespecial&nbsp;#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/lang/Object."&lt;init&gt;":()V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;3:&nbsp;0&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(java.lang.String[]);&nbsp;&nbsp;&nbsp;&nbsp;Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;astore_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;Java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;astore_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;getstatic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Field&nbsp;java/lang/System.out:Ljava/io/PrintStream;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9:&nbsp;aload_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;aload_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11:&nbsp;if_acmpne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14:&nbsp;iconst_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15:&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18:&nbsp;iconst_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19:&nbsp;invokevirtual&nbsp;#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;java/io/PrintStream.println:(Z)V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22:&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;LineNumberTable:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;5:&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;6:&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;7:&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;8:&nbsp;22}</code></pre><p>从编译代码#2可以看出，代码”Ja”+”va”被直接编译成了“Java”，因此s1==s2的结果才是true，这就是编译器对字符串优化的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
